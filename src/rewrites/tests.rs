#![cfg(test)]

use crate::{cost::OperatorCost, hooks, rewrites::rules, RecExpr, Runner};
use egg::{Extractor, Id, StopReason};

egg::test_fn! {
    fuse_maps,
    rules(),
    "(map (map input0 func0) func1)"
        => "(map input0 (fun (apply func1 (apply func0 #0))))"
}

egg::test_fn! {
    fuse_filters,
    rules(),
    "(filter (filter input0 func0) func1)"
    =>
    "(filter ?stream
        (fun (and (apply ?filter1 #0)
                  (apply ?filter2 #0))))"
}

egg::test_fn! {
    simplify_and_then,
    rules(),
    "(and_then (and_then none true) none)" => "none"
}

egg::test_fn! {
    fuse_filter_map_with_filter,
    rules(),
    "(filter (filter_map input0 func0) func1)"
    =>
    "(filter_map input0
        (fun (filter_opt (apply func0 #0) func1)))"
}

egg::test_fn! {
    remove_redundant_arrange_by_keys,
    rules(),
    "(arrange_by_key
        (arrange_by_key
            (arrange_by_key input0)))"
    =>
    "(arrange_by_key input0)"
}

egg::test_fn! {
    remove_redundant_arrange_by_selfs,
    rules(),
    "(arrange_by_self (arrange_by_self (arrange_by_self input0)))"
        => "(arrange_by_self input0)"
}

egg::test_fn! {
    reversed_join_simplifies,
    rules(),
    "(join_map input1 input0
        (fun (rev_tuple #0)))"
    =>
    "(join input0 input1)"
}

egg::test_fn! {
    join_stays_simple,
    rules(),
    "(join input0 input1)"
        => "(join input0 input1)"
}

egg::test_fn! {
    reversed_join_map_simplifies,
    rules(),
    "(join_map input0 input1
        (fun (apply func0 (rev_tuple #0))))"
        => "(join_map input1 input0 func0)"
}

egg::test_fn! {
    join_map_stays_simple,
    rules(),
    "(join_map input1 input0 func0)"
        => "(join_map input1 input0 func0)"
}

egg::test_fn! {
    const_evaluation,
    rules(),
    "(eq (add 1 (sub 1000 900)) (add 1 (add 1 (add 1 (add 1 (add 1 (add 1 (add 1 1))))))))"
        => "false"
}

egg::test_fn! {
    merge_differently_named_functions,
    rules(),
    "(list (fun (add #0 1)) (fun (add #0 1)))"
        => "(list (fun (add #0 1)) (fun (add #0 1)))"
}

egg::test_fn! {
    adjacent_arrangements,
    rules(),
    "(arrange_by_key (as_collection (arrange_by_key ?x) (fun #0)))"
        => "(arrange_by_key ?x)"
}

// Actual thing generated by ddlog
egg::test_fn! {
    fuse_comparisons,
    rules(),
    "(or (<= ?a ?b)
         (or (eq ?a ?b)
             (or (< ?a ?b)
                 (or (neq ?a ?b)
                     (or (>= ?a ?b)
                         (or (< ?a ?b) (> ?a ?b)))))))"
    => "true"
}

#[test]
fn join_map_and_tuples_saturate() {
    let expr: RecExpr = "(join_map input0 input1 func0)".parse().unwrap();

    let runner: Runner = Runner::default()
        .with_iter_limit(3)
        .with_expr(&expr)
        .run(&rules());

    assert!(
        matches!(runner.stop_reason, Some(StopReason::Saturated)),
        "stopped with reason {:?}",
        runner.stop_reason,
    );
}

#[test]
fn join_filter_and_tuples_saturate() {
    let expr: RecExpr = "(join_filter input0 input1 func0)".parse().unwrap();

    let runner: Runner = Runner::default()
        .with_iter_limit(3)
        .with_expr(&expr)
        .run(&rules());

    assert!(
        matches!(runner.stop_reason, Some(StopReason::Saturated)),
        "stopped with reason {:?}",
        runner.stop_reason,
    );
}

#[test]
fn optimize_fibonacci() {
    #[rustfmt::skip]
    const FIBONACCI: &str =
        "(let FibonacciFor input0
            (let NeedsFibonacci
                (concat (var FibonacciFor)
                        (filter_map (var FibonacciFor)
                            (fun (if (>= #0 1)
                                     (some (sub #0 1))
                                     none)))
                        (filter_map (var FibonacciFor)
                            (fun (if (>= #0 2)
                                     (some (sub #0 2))
                                     none))))
                (let FibonacciLoop
                    (map
                        (join
                            (arrange_by_key
                                (map
                                    (join (arrange_by_self (var NeedsFibonacci))
                                          (arrange_by_key (map (var FibonacciLoop) (fun (sub #0 1)))))
                                    (fun (case #0 (tuple _ _) (tuple #3 #0)))))
                            (arrange_by_key
                                (map
                                    (join (arrange_by_self (var NeedsFibonacci))
                                          (arrange_by_key (map (var FibonacciLoop) (fun (sub #0 2)))))
                                    (fun (case #0 (tuple _ _) (tuple #3 #0))))))
                        (fun (case #0 (tuple _ _) (tuple #3 (add #1 #0)))))
                    unit)))";

    let expr: RecExpr = FIBONACCI.parse().unwrap();
    let runner = Runner::default()
        .with_hook(|runner| {
            hooks::variable_propagation(&mut runner.egraph, &runner.roots);
            Ok(())
        })
        .with_expr(&expr)
        .run(&rules());
    let (egraph, root) = (runner.egraph, runner.roots[0]);

    let mut extractor = Extractor::new(&egraph, OperatorCost::new(&egraph, &runner.roots));
    let (best_cost, best) = extractor.find_best(root);
    println!("{}: {}", best_cost, best.pretty(80));

    let mut ids: Vec<Id> = egraph.classes().map(|class| class.id).collect();
    ids.sort();

    for id in ids {
        let node = &egraph[id];
        let data = &node.data;

        let mut nodes = node.nodes.clone();
        nodes.sort();

        print!("{}: {:?}", id, nodes);
        if let Some(constant) = data.constant.as_ref() {
            print!(", constant: {:?}", constant);
        }
        if let Some(ty) = data.ty.as_ref() {
            print!(", type: {:?}", ty);
        }
        println!();
    }
}
